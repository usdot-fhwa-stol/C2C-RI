/*
    Jameleon - An automation testing tool..
    Copyright (C) 2003-2006 Christian W. Hargraves (engrean@hotmail.com)
    
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
*/
package net.sf.jameleon;

import net.sf.jameleon.data.AbstractDataDrivableTag;
import net.sf.jameleon.exception.JameleonScriptException;
import net.sf.jameleon.result.*;
import net.sf.jameleon.util.JameleonUtility;
import net.sf.jameleon.util.StateStorer;
import org.apache.commons.jelly.JellyTagException;
import org.apache.commons.jelly.LocationAware;
import org.apache.commons.jelly.MissingAttributeException;
import org.apache.commons.jelly.XMLOutput;
import org.apache.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Properties;
/**
 * <p>A Session is the state of an application from one functional point to the next. In order
 *    to allow for independent functional points, a handle on the application's state
 *    must be kept between functional points. This handle is implemented differently for each
 *    application interface technology. Some examples of interfaces might be a GUI application
 *    implemented in Swing or .NET, an HTTP application or even a SQL inteface to the database.
 * </p>
 * <p>A SessionTag is required for every interface, even those that don't require a handle 
 *    on the application to be shared across the many functional points. There should still be
 *    a generic way to start and stop the application. A SessionTag is also a means to use only
 *    variables defined in Applications.properties that are pertinent to a particular application
 *    and it helps separate the autogenerated docs when accessing several applications
 *    in a test.
 * </p>
 * <p>Implementing an interface-specific SessionTag includes implementing the following methods:
 * <ul>
 *  <li>{@link #setUpSession()} - This method is called after @see #init() and should be used to create
 *                             all plug-in related resources and configure any plug-in/session specific
 *                             settings.
 *  <li>{@link #tearDownSession()} - This method is called right after all children tags have been executed
 *                                and should clean up any resources created by the session tag</li>
 *  <li>{@link #startApplication()} - This method is used to start the application and is called only when 
 *                                 <code>beginSession</code> is set to <code>true</code>. If this method
 *                                 doesn't make sense for the particular plug-in, then simply don't 
 *                                 implement it.</li>
 * </ul>
 * </p>
 * <p>If the application type being tested supplies some kind of handle, then the SessionTag is the appropriate place
 *    to keep it. Create an instance variable representing the application's handle and provide a public get and set
 *    method for it. The abstract function tag will then get an instance of this SessionTag and get the handle
 *    off the application.
 * </p>
 * <p>
 *    This base class is interface agnostic and implements all Jameleon-specific behavior. The
 *    following is a list of supported attributes supported by this class:
 *    <ul>
 *     <li>sessionResults - This is a generic result. It keeps track of a lot of stuff, however. {@link net.sf.jameleon.result.SessionResult}.</li>
 *     <li>application    - The name of the application being tested. This used to grab information about the application transparently for the
 *                          funtional points. Can be set via the <code>application</code> attribute in the appropriate session tag.</li>
 *     <li>organization   - The name of the organization this Session is running tests against. This is not required and is also used to transparently
 *                          get information regarding the URL to start on and any other attributes which might be specific to an application and or an enviroment.
 *                          <code>organization</code> can also be set with the <code>organization</code> attribute in either the test case or in the
 *                          appropriate session tag. This would only need to be set in the session if the organization is set in the the test case
 *                          the application being tested in this session is different from that in the test case.</li>
 *     <li>log            - An instance of the @see java.util.loggin.Logger class. This is the means that Jameleon uses for it's logging..
 *    </ul>
 * </p>
 */
public abstract class SessionTag extends JameleonTagSupport implements Storable, 
                                                                       FunctionResultRecordable,
                                                                       DataDrivableResultRecordable{

    protected SessionResult sessionResults;
    /**
     * The name of the application being run according to the *-TestCaseTag.properties file
     * @jameleon.attribute
     */
    protected String application;
    /**
     * The organization (affiliate or company name) this application will be tested against.
     * @jameleon.attribute
     */
    protected String organization;
    /**
     * @jameleon.attribute
     */
    protected boolean postcondition;
    /**
     * Sets the tag to delay x milliseconds before anything else is executed.
     * @jameleon.attribute default="0"
     */
    protected long sessionDelay;
    protected static Logger log = Logger.getLogger(SessionTag.class.getName());
    protected Properties props;
    protected TestCaseTag tc;
    protected AbstractDataDrivableTag addt;

    private String tcOrganization;

    /**
     * Starts the applicattion and gets it to the state defined in the $testEnviroment-Applications.properties.
     * DEFAULTS to <code>false</code>
     * @jameleon.attribute
     */
    protected boolean beginSession = false;

    /**
     * Default constructor. Currently it does nothing.
     */
    public SessionTag(){
        super();
        application = new String();
    }

    /**
     * @return the organization (affiliate or company name) this application will be tested against.
     * This would used for when there is one application for many different datasources
     * like a shopping being installed against several different customers. This is also
     * important because the URLs change between organizations as well.
     */
    public String getOrganization(){
        return organization;
    }

    public void setOrganization(String organization){
        this.organization = organization;
    }

    /**
     * The name of the application being run according to the *-TestCaseTag.properties file
     * @return the name of the application being run under this session.
     */
    public String getApplication(){
        return this.application;
    }

    public void setSessionDelay(long sessionDelay){
        this.sessionDelay = sessionDelay;
    }

    /**
     * A TagSupport specific method. This method calls any or all sub element tags ( like function point tags ).
     */
    public void doTag(XMLOutput out) throws MissingAttributeException, JellyTagException{
        init();
        traceMsg("Beginning Session: \""+ getFunctionalPoint().getDefaultTagName()+"\"");
        testForUnsupportedAttributesCaught();
        broker.transferAttributes(context);
        broker.validate(context);
        setUpSession();
        long startTime = System.currentTimeMillis();
        try {
            if (tc.isExecuteTestCase()) {
                delaySession();
                if (beginSession &&
                    (!addt.getFailedOnCurrentRow() || postcondition)) {
                    traceMsg("Begin: starting application");
                    startApplication();
                    traceMsg("End: starting application");
                }
            }
        } catch (RuntimeException e) {
            sessionResults.setError(e);
            log.debug(JameleonUtility.getStack(e));
            addt.setFailedOnCurrentRow(true);
        }
        try {
            invokeBody(out);
        } catch (ThreadDeath td){
            throw td;
        } catch (Throwable t) {
            LocationAware la = null;
            Throwable err = t;
            if (t.getCause() != null && t.getCause() instanceof LocationAware) {
                err = t.getCause();
                la = (LocationAware)err;
            }else if (t instanceof LocationAware) {
                la = (LocationAware)t;
            }
            if (la != null) {
                la.setColumnNumber(getColumnNumber());
                la.setLineNumber(getLineNumber());
                la.setFileName(getFileName());
                JameleonScriptException jse = new JameleonScriptException(err.getMessage(), la);
                sessionResults.setError(jse);
                //throw jse;
            }else{
                sessionResults.setError(err);
            }
        } finally {
            sessionResults.setExecutionTime(System.currentTimeMillis()-startTime);
            // A hack to show the variables created during execution of a function point( like the variable mapping feature )
            //sessionResults.getParams().putAll(context.getVariables());
            removeChildlessResult();
            log.debug(sessionResults);
            if (tcOrganization != null) {
                tc.setOrganization(tcOrganization);
                context.setVariable("organization", tcOrganization);
            }
            tearDown();
        }
    }
    
    protected void tearDown(){
        props = new Properties();
        traceMsg("Ending Session: \""+getFunctionalPoint().getDefaultTagName()+"\"");
        traceMsg("\n");
        tearDownSession();
        sessionResults.setTag(fp.cloneFP());
        resetFunctionalPoint();
    }

    /**
     * Used for the trace functionality. Only sends info to the log if trace is enabled.
     * @deprecated - use traceMsg instead.
     */
    protected void trace(String msg){
    	traceMsg(msg);
    }

    /**
     * Used for the trace functionality. Only sends info to the log if trace is enabled.
     */
    protected void traceMsg(String msg){
        if (tc != null && tc.getTrace()) {
            System.out.println(msg+"\n");
        }else{
        	log.debug(msg);
        }
    }

    //Storable Methods
    /**
     * <p>
     * Stores the current state of the object to a given <code>File</code>. The default
     * implementation of this method does nothing. Override this method to implement
     * plug-in specific behavior. Some examples might be:</p>
     * <ul>
     *  <li>Saving the HTML from an HTTP plug-in during a state change or error</li>
     *  <li>Taking a screen shot for a GUI application during a state change event</li>
     * </ul>
     * <p>
     * A listener is already registered for each function tag. All that is required is
     * implementing this method.</p>
     * @param filename the name of the if the file to store the contents to.
     * @param event The {@link net.sf.jameleon.util.StateStorer event} that occured (error, state change ...).
     * @throws IOException If the state of the object could not be stored in File <code>f</code>.
     */
    public void store(String filename, int event) throws IOException{
    }

    /**
     * Gets the filename to store the state of the application to. 
     * The default implementation is to simply use timestamps. 
     * If this is not the desired behavior, override this method.
     * @param event - the StateStorer Event
     * @return the appropriate filename which starts with ERROR- if the StateStorer Event was an Error
     */
    public String getStoreToFileName(int event){
        String filename = System.currentTimeMillis() +"";
        if ( event == StateStorer.ON_ERROR_EVENT ) {
            filename = "ERROR-"+filename;
        }
        return filename;
    }

    //End Storable Methods
    /**
     * Called when the session tag is closed. This should clean up
     * all plug-in specific resources created by this session.
     */
    protected void tearDownSession(){}

    protected void findParentTestCase() {
        tc =  (TestCaseTag)findAncestorWithClass(TestCaseTag.class);
    }

    /**
     * Grabs information about the application and the organization from the test case.
     * Adds the test case results to the session results so that overall statistics will be kept in the
     * test case results.
     */
    protected void init() throws MissingAttributeException{
        findParentTestCase();
        addt = (AbstractDataDrivableTag)findAncestorWithClass(AbstractDataDrivableTag.class);
        if (organization != null && organization.trim().length() > 0) {
            tcOrganization = tc.getOrganization();
            context.setVariable("organization", organization);
            tc.setOrganization(organization);
            tc.validateAttributes();
        } else {
            organization = tc.getOrganization();
        }

        Object obj = findAncestorWithClass(PostconditionTag.class);
        if (obj != null) {
            postcondition = true;
        }

        sessionResults = new SessionResult(fp);
        sessionResults.copyLocationAwareProperties(this);
        obj = findAncestorWithClass(SessionResultRecordable.class);
        if (obj != null) {
            ((SessionResultRecordable)obj).recordSessionResult(sessionResults);
        }
        context.setVariable("session_application", application);
        props = tc.getPropertiesForApplication(application);
    }

    /**
     * @return The results of this session. This should contain all environment variables used as well
     * as all of the asserts.
     */
    public SessionResult getSessionResult(){
        return sessionResults;
    }

    /**
     * Is called before anything else specific to the interface is called. This method should
     * create all resources required for this session to begin. The default behavior is to
     * do nothing.
     */
    public void setUpSession(){}

    /**
     * Used for the plug-in to implement if something special is required during the session setup.
     * The properties from the CSV and testEnvironment.properties are setup before this method is called.
     * The default implementation does nothing.
     */
    public void startApplication(){}

    protected void delaySession(){
        if (sessionDelay > 0) {
            synchronized (this){ 
                try {
					while (sessionDelay > 0)
					{
						this.wait(sessionDelay); 
					}
                } catch (InterruptedException e) {
                    e.printStackTrace(); 
					Thread.currentThread().interrupt();
                }
            } 
        }
    }


    /**
     * Removes the current result from its parent if it has no children, meaning the tags weren't actually run
     */
    protected void removeChildlessResult(){
        if (sessionResults.passed() && 
            ( sessionResults.getChildrenResults() == null || 
              sessionResults.getChildrenResults().size() == 0) ) {

            if (sessionResults.getParentResults() != null) {
                List results = sessionResults.getParentResults().getChildrenResults();
                if (results != null) {
                    int index = results.lastIndexOf(sessionResults);
                    results.remove(index);
                }
            }
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////
    //                      FunctionResultRecordable implementation methods                     //
    //////////////////////////////////////////////////////////////////////////////////////////////
    
    protected void recordResult(JameleonTestResult result){
        if (sessionResults != null) {
            sessionResults.addChildResult(result);
            result.setParentResults(sessionResults);
        }
    }
    /**
     * Records a FunctionResult to the tag's results and sets the FunctionResult's parent
     * result to itself
     * @param result
     */
    public void recordFunctionResult(FunctionResult result) {
        recordResult(result);
    }
    /**
     * Records a DataDrivableResultContainer to the tag's results
     * @param result
     */
    public void recordDataDrivableResult(DataDrivableResultContainer result){
        recordResult(result);
    }
}
